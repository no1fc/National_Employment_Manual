---
적용: 항상
---

핵심 규칙: 간단한 시작점
1. 코딩 선호도 – “이렇게 코드를 작성하세요”
   목적: 깨끗하고 유지보수 가능하며 효율적인 코드를 보장합니다.

규칙:

단순성: “복잡성보다 가장 간단한 솔루션을 항상 우선시하세요.” (Matthew Berman)
중복 없음: “코드 반복을 피하고, 가능한 경우 기존 기능을 재사용하세요.” (Matthew Berman, DRY from u/DonkeyBonked)
조직화: “파일을 간결하게 유지하고, 200-300줄 이내로 하며, 필요에 따라 리팩토링하세요.” (Matthew Berman)
문서화: “주요 구성 요소 개발 후에는 /docs/[component].md(예: login.md)에 간략한 요약을 작성하세요.” (u/believablybad)
왜 효과적인가: 단순한 코드는 버그를 줄이고, 문서화는 읽기 쉬운 감사 추적을 제공합니다.

2. 기술 스택 – “이런 도구를 사용하세요”
   목적: AI를 사용자가 선호하는 기술에 제한합니다.

규칙(Berman의 예):

“백엔드는 Python으로 작성.”
“프론트엔드는 HTML과 JavaScript로 작성.”
“데이터는 JSON 파일이 아닌 SQL 데이터베이스에 저장.”
“테스트는 Python으로 작성.”
왜 효과적인가: 일관성을 유지하여 AI가 프로젝트 중간에 도구를 전환하는 것을 방지합니다.

3. 워크플로우 선호도 – “이렇게 작업하세요”
   목적: 예측 가능성을 위해 AI의 실행 프로세스를 제어합니다.

집중: “내가 지정한 코드만 수정하고, 나머지는 모두 손대지 마세요.” (Matthew Berman)
단계: “큰 작업을 단계로 나누고, 각 단계 후에 내 승인을 기다리세요.” (u/xmontc)
계획: “큰 변경 전에는 plan.md를 작성하고 내 확인을 기다리세요.” (u/RKKMotorsports)
추적: “완료된 작업은 progress.md에, 다음 단계는 TODO.txt에 기록하세요.” (u/illusionst, u/petrhlavacek)
왜 효과적인가: 점진적인 단계와 로그를 통해 프로세스를 투명하고 관리 가능하게 유지합니다.

4. 커뮤니케이션 선호도 – “이렇게 대화하세요”
   목적: AI로부터 명확하고 실행 가능한 피드백을 보장합니다.

요약: “각 구성 요소 완료 후에는 완료된 내용을 요약하세요.” (u/illusionst)
변경 규모: “변경사항을 작은(Small), 중간(Medium), 또는 큰(Large) 규모로 분류하세요.” (u/illusionst)
명확화: “내 요청이 불분명하면 진행하기 전에 질문하세요.” (u/illusionst)
왜 효과적인가: AI의 의도를 해독할 필요 없이 명확한 정보를 받을 수 있습니다.

고급 규칙: 복잡한 프로젝트를 위한 확장
1. 코딩 선호도 – 품질 향상
   확장:

원칙: “적용 가능한 경우 SOLID 원칙(예: 단일 책임, 의존성 역전)을 따르세요.” (u/Yodukay, u/philip_laureano)
가드레일: “개발이나 프로덕션 환경에서 모의 데이터를 사용하지 마세요—테스트에만 제한하세요.” (Matthew Berman)
컨텍스트 확인: “컨텍스트 유지를 확인하기 위해 모든 응답을 랜덤 이모지(예: 🐙)로 시작하세요.” (u/evia89)
효율성: “명확성을 희생하지 않고 토큰 사용을 최소화하도록 출력을 최적화하세요.” (u/Puzzleheaded-Age-660)
기술적 통찰: SOLID는 모듈성을 보장합니다(예: 로그인 모듈이 트윗 처리를 담당하지 않음). 이모지는 컨텍스트가 모델 한계(일반적으로 Claude 3.7의 경우 200k 토큰)를 초과할 때 신호를 보냅니다.

2. 기술 스택 – 사용자 정의
   확장:

“추가 도구를 지정하는 경우(예: 검색용 Elasticsearch), 여기에 포함하세요.” (Matthew Berman)
“내 명시적 승인 없이는 스택을 절대 변경하지 마세요.” (Matthew Berman)
기술적 통찰: 고정된 스택은 AI가 호환되지 않는 종속성(예: SQL에서 JSON으로 전환)을 도입하는 것을 방지합니다.

3. 워크플로우 선호도 – 프로세스 마스터리
   확장:

테스팅: “주요 기능에 대한 포괄적인 테스트를 포함하고, 엣지 케이스 테스트(예: 잘못된 입력)를 제안하세요.” (u/illusionst)
컨텍스트 관리: “컨텍스트가 100k 토큰을 초과하면 context-summary.md에 요약하고 세션을 재시작하세요.” (u/Minimum_Art_2263, u/orbit99za)
적응성: “내 피드백에 따라 체크포인트 빈도를 조정하세요(더 많거나 적은 세분화).” (u/illusionst)
기술적 통찰: 토큰 한계(예: Claude의 200k)는 100k를 넘어서면 성능이 저하됩니다. 요약은 연속성을 유지하는 데 도움이 되며, 테스트는 초기에 회귀 문제를 감지합니다.

4. 커뮤니케이션 선호도 – 정밀 상호작용
   확장:

계획: “대규모(Large) 변경사항의 경우 구현 계획을 제공하고 승인을 기다리세요.” (u/illusionst)
추적: “항상 완료된 작업과 보류 중인 작업을 명확히 명시하세요.” (u/illusionst)
감정적 신호: “내가 긴급성을 나타내면(예: ‘이것은 중요합니다—실수하지 마세요!’), 주의와 정밀함을 우선시하세요.” (u/dhamaniasad, u/capecoderrr)
기술적 통찰: 변경 분류(S/M/L)는 영향을 정량화합니다(예: Small = 50줄 미만, Large = 아키텍처 변경). 감정적 신호는 AI가 훈련 데이터 패턴을 활용하여 더 나은 준수를 이끌어낼 수 있습니다.